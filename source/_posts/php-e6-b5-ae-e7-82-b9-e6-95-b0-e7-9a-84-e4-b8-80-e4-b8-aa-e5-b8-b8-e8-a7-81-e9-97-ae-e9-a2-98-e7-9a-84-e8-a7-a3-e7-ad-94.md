---
title: PHP浮点数的一个常见问题的解答
tags:
  - PHP浮点数
url: 292.html
id: 292
categories:
  - PHP
date: 2015-03-30 10:57:55
---

作者: [Laruence](http://www.laruence.com/) 本文地址: [http://www.laruence.com/2013/03/26/2884.html](http://www.laruence.com/2013/03/26/2884.html "Permanet Link to PHP浮点数的一个常见问题的解答") 转载请注明出处

关于PHP的浮点数, 我之前写过一篇文章: [关于PHP浮点数你应该知道的(All ‘bogus’ about the float in PHP)](http://www.laruence.com/2011/12/19/2399.html) 不过, 我当时遗漏了一点, 也就是对于如下的这个常见问题的回答:

1.  <?php
2.      $f=0.58;
3.      var_dump(intval($f*100));//为啥输出57
4.  ?>

为啥输出是57啊? PHP的bug么? 我相信有很多的同学有过这样的疑问, 因为光问我类似问题的人就很多, 更不用说bugs.php.net上经常有人问… 要搞明白这个原因, 首先我们要知道浮点数的表示([IEEE 754](http://en.wikipedia.org/wiki/IEEE_754-2008)): 浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位). 符号位：最高位表示数据的正负，0表示正数，1表示负数。 指数位：表示数据以2为底的幂，指数采用偏移码表示 尾数：表示数据小数点后的有效数字. 这里的关键点就在于, 小数在二进制的表示, 关于小数如何用二进制表示, 大家可以百度一下, 我这里就不再赘述, 我们关键的要了解, 0.58 对于二进制表示来说, 是无限长的值(下面的数字省掉了隐含的1)..

1.  0.58的二进制表示基本上(52位)是: 0010100011110101110000101000111101011100001010001111
2.  0.57的二进制表示基本上(52位)是: 0010001111010111000010100011110101110000101000111101

而两者的二进制, 如果只是通过这52位计算的话,分别是:

1.  0.58 -> 0.57999999999999996
2.  0.57 -> 0.56999999999999995

至于0.58 * 100的具体浮点数乘法, 我们不考虑那么细, 有兴趣的可以看([Floating point](http://en.wikipedia.org/wiki/Floating_point)), 我们就模糊的以心算来看… 0.58 * 100 = 57.999999999 那你intval一下, 自然就是57了…. 可见, 这个问题的关键点就是: “你看似有穷的小数, 在计算机的二进制表示里却是无穷的” so, 不要再以为这是PHP的bug了, 这就是这样的…..