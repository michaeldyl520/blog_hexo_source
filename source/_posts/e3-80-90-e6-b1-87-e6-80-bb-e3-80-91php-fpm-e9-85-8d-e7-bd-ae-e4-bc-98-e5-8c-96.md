---
title: 【汇总】PHP-FPM 配置优化
tags:
  - PHP-FPM优化
  - PHP-FPM配置
url: 305.html
id: 305
categories:
  - php-fpm
date: 2015-03-30 11:07:24
---

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-**开启php-fpm慢脚本日志** request\_slowlog\_timeout = 30s slowlog = /usr/local/php/var/log/php-fpm.log.slow 典型的日志内容如下： \[15-Apr-2012 20:56:19\] \[pool www\] pid 9748 script\_filename = /var/www/html/htdocs/www.xxx.com/xxx.php \[0x00000000090bc270\] file\_get\_contents() /var/www/html/htdocs/www.xxx.com/xxx.php:81 慢脚本文件、具体行数、函数等都很详细的记录了，优化工作相对来说就容易的多。 request\_terminate\_timeout = 120 #表示等待120秒后，结束那些没有自动结束的php脚本，以释放占用的资源。 当PHP运行在php-fpm模式下，php.ini配置的max\_execute\_time是无效的，需要在php-fpm.conf中配置另外一个配置项:request\_terminate\_timeout;以下是官方文档的说明： request\_terminate\_timeout – The timeout (in seconds) for serving a single request after which the worker process will be terminated. Should be used when ‘max\_execution\_time’ ini option does not stop script execution for some reason. Default: “5s”. Note: ’0s’ means ‘off’ 注意:set\_time\_limit()和max\_execution\_time只影响脚本本身执行的时间。任何发生在诸如使用system()的系统调用，流操作，数据库操作等的脚本执行的最大时间不包括其中. \[global\] pid = /dev/shm/pid/php-fpm.pid error\_log = /usr/local/php/var/log/php-fpm.log log\_level = notice \[www\] listen = 127.0.0.1:9000 ;listen.allowed\_clients = 192.168.1.17,127.0.0.1,192.168.1.75 user = www group = www pm = dynamic pm.max\_children = 2000 pm.start\_servers = 10 pm.min\_spare\_servers = 5 pm.max\_spare\_servers = 200 pm.max\_requests = 12000 pm.process\_idle\_timeout = 10s request\_terminate\_timeout = 120 request\_slowlog\_timeout = 30s slowlog = /usr/local/php/var/log/php-fpm.log.slow 这里先说一下涉及到这个的几个参数，他们分别是pm、pm.max\_children、pm.start\_servers、pm.min\_spare\_servers和pm.max\_spare\_servers。 pm表示使用那种方式，有两个值可以选择，就是static（静态）或者dynamic（动态）。在更老一些的版本中，dynamic被称作apache-like。这个要注意看配置文件的说明。 下面4个参数的意思分别为： pm.max\_children：静态方式下开启的php-fpm进程数量。 pm.start\_servers：动态方式下的起始php-fpm进程数量。 pm.min\_spare\_servers：动态方式下的最小php-fpm进程数量。 pm.max\_spare\_servers：动态方式下的最大php-fpm进程数量。 如果dm设置为static，那么其实只有pm.max\_children这个参数生效。系统会开启设置数量的php-fpm进程。 **如果dm设置为 dynamic，那么pm.max_children参数失效，后面3个参数生效。** 系统会在php-fpm运行开始 的时候启动pm.start\_servers个php-fpm进程， 然后根据系统的需求动态在pm.min\_spare\_servers和 pm.max\_spare\_servers之间调整php-fpm进程数。 那么，对于我们的服务器，选择哪种执行方式比较好呢？事实上，跟Apache一样，运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。 这也是为什么开始的时候一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。 对于内存大的服务器（比如8G以上）来说，指定静态的max\_children实际上更为妥当，因为这样不需要进行额外的进程数目控制，会提高效 率。 因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据 内存/30M 得到，比如8GB内存可以设置为100， 那么php-fpm耗费的内存就能控制在 2G-3G的样子。如果内存稍微小点，比如1G，那么指定静态的进程数量更加有利于服务器的稳定。 这样可以保证php-fpm只获取够用的内存，将不多的 内存分配给其他应用去使用，会使系统的运行更加畅通。 对于小内存的服务器来说，比如256M内存的VPS，即使按照一个20M的内存量来算，10个php-cgi进程就将耗掉200M内存，那系统的崩 溃就应该很正常了。 因此应该尽量地控制php-fpm进程的数量，大体明确其他应用占用的内存后，给它指定一个静态的小数量，会让系统更加平稳一些。或者使用动态方式， 因为动态方式会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或VPS上使用。具体最大数量根据 内存/20M 得到。 比如说512M的VPS，建议pm.max\_spare\_servers设置为20。至于pm.min\_spare\_servers，则建议根据服 务器的负载情况来设置，比较合适的值在5~10之间。 ============================= 127.0.0.1监听本机ip php-fpm.conf listen = 127.0.0.1:9000 nginx.conf location ~ ^(.+\\.php)(.*)$ { fastcgi\_pass   127.0.0.1:9000; fastcgi\_index  index.php; include fcgi.conf; }